Установка:  
* https://tproger.ru/articles/kak-ustanovit-kubernetes-s-minikube-na-linux/
* https://habr.com/ru/company/flant/blog/333470/
* https://habr.com/ru/company/vk/blog/648117/

Подсказки в терминал:
* https://kubernetes.io/ru/docs/reference/kubectl/cheatsheet/

Команды:  
- kubectl version --short
- minikube start
- kubectl get pods --all-namespaces //список запущенных в кластере подов
- kubectl get nodes //список запущенных нод
- kubectl get pods
- kubectl get deployments
- kubectl expose deployment hello-minikube --type=NodePort //Для доступа к сервису hello-minikube нужно открыть ему внешний IP командой 
необходимо использовать тип NodePort, т.к. Minikube не поддерживает сервис LoadBalancer
- kubectl get services //можно убедиться, что сервис стал открыт
- minikube service hello-minikube --url //узнать его внешний IP и порт
- kubectl delete service,deployment hello-minikube

Пример:  
- kubectl create deployment hello-minikube --image=k8s.gcr.io/echoserver:1.10 --port=8080

Настройки памяти и процессора с помощью команды:
- $ minikube config set memory 6144
- $ minikube config set cpus 4
- $ minikube start --memory 6144 --cpus 4
- $ minikube start --memory=max --cpus=max

Указание версии Kubernetes:
- $ minikube start --kubernetes-version=v1.19.0
Также имеет смысл указать версию Kubernetes, когда вы тестируете несколько кластеров, работающих на разных версиях. Для этого используйте флаг --profile:
- $ minikube start -p dev --kubernetes-version=v1.19.0
- $ minikube start -p stage --kubernetes-version=v1.18.0

Локальные образы Docker
Если кластер построен на основе среды исполнения контейнера Docker (в отличие от cri-o или containerd), укажите для терминала использование внутреннего демона Docker в кластере с помощью команды:
- $ eval $(minikube docker-env)

Чтобы включить другие дополнения, выполните команду:
- $ minikube addons enable <название дополнения>

Поднять kubernetes кластер на KVM:
- minikube start --driver=kvm2

Поднять kubernetes кластер на VirtualBox:
- minikube start --vm-driver=virtualbox

Загрузить образ в кластер, причём надо проделать ровно столько раз сколько у вас нод:
- minikube image load hello-minikube:latest

Открыть dashboard:
- minikube dashboard

Посмотреть URL для доступа к сервисуhello-minikube :
- minikube service list

Правда есть одно "но", minikube по умолчанию делает активным свой контекст для kubectl:
- CURRENT  NAME  CLUSTER  AUTHINFO  NAMESPACE * minikube minikube minikube default

Пример YML (pod.yml):
``` yml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod-1
spec:
  Containers:
  - image: quay.io/testing-farm/nginx:1.12
    name: nginx
    ports:
    - containerPort: 80
```

Рассмотрим некоторые объекты Kubernetes:


Namespace — пространство имен. Объекты могут взаимодействовать, только если находятся в одном неймспейсе. С помощью неймспейсов возможно развернуть несколько виртуальных кластеров на одном физическом.


Pod — минимальный юнит развертывания. В большинстве случаев включает в себя один контейнер. Множество настроек пода делегируются непосредственно контейнеру докера, например, управление ресурсами, политики рестартов, управление портами.


ReplicaSet — контроллер, позволяющий создать набор одинаковых подов и работать с ними, как с единой сущностью. Поддерживает нужное количество реплик, при необходимости создавая новые поды или убивая старые. На самом деле в большинстве случаев вы не будете работать с ReplicaSet напрямую — для этого есть Deployment.


Deployment — контроллер развертывания, являющийся абстракцией более высокого уровня над ReplicaSet'ом. Добавляет возможность обновления управляемых подов.


Service — отвечает за сетевое взаимодействие группы подов. В системе обычно существует несколько экземляров одного микросервиса, соответственно каждый из них имеет свой IP-адрес. Количество подов может изменяться, следовательно набор адресов также не постоянен. Другим частям системы для доступа к рассматриваемым подам нужен какой-то статичный адрес, который Service и предоставляет.


Во избежание путаницы здесь и в дальнейшем под словом "сервис" я буду подразумевать именно объект Kubernetes, а не экземпляр приложения.


Существует несколько видов сервисов. Перечисленные ниже типы для простоты понимания можно рассматривать, как матрешку. Каждый последующий оборачивает предыдущий и добавляет некоторые правила маршрутизации. Создавая сервис более высокого уровня, автоматически создаются сервисы нижележащего типа. Типы сервисов:


ClusterIP — дефолтный тип сервиса. Единая точка доступа к подам по постоянному IP-адресу, доступному только изнутри кластера.
NodePort — общий IP-адрес подов (полученный из ClusterIP) соединяется с определенным портом всех нод, на которых развернуты обслуживаемые поды. Поды становятся доступны по адресу <NodeIP>:<NodePort>.
LoadBalancer — выходной порт NodePort присоединяется к внешнему балансировщику нагрузки, предоставляемому облачным провайдером. Таким образом мы получаем статический внешний IP-адрес для нашего приложения.

Также Kubernetes из коробки предоставляет поддержку DNS внутри кластера, позволяя обращаться к сервису по его имени. Более подробно про сервисы можно почитать тут.


ConfigMap — объект с произвольными конфигурациями, которые могут, например, быть переданы в контейнеры через переменные среды.


Secret — объект с некой конфиденциальной информацией. Секреты могут быть файлами (№ SSL-сертификатами), которые монтируются к контейнеру, либо же base64-закодированными строками, передающимися через те же переменные среды. В статье будут рассмотрены только строковые секреты.


HorizontalPodAutoscaler — объект, предназначенный для автоматического изменения количества подов в зависимости от их загруженности.


